# 12. 함수

## 함수란?

함수는 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행단위로 정의한 것

## 함수를 사용하는 이유

1. 코드의 재사용
2. 유지 보수의 편의성
3. 코드의 신뢰성 향상
4. 코드의 가독성 향상

## 함수 리터럴

함수 리터럴도 평가되어 값을 생성하며, 이 값은 객체다

즉 함수는 `객체`

하지만 일반객체는 호출할 수 없지만, 함수는 호출할 수 있다.

## 함수 정의

함수 선언문, 함수 표현식, Function 생성자 함수, 화살표 함수로 표현할 수 있다.

### 함수 선언문

```js
function add(x,y){
    return x+y;
}
```

함수 선언문은 함수 이름을 생략할 수 없다.

자바스크립트 엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당한다.

함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출한다.

### 함수 표현식

함수는 `일급객체`

= 함수는 값처럼 변수에 할당할 수 있고, 프로퍼티 값이 될 수도 있고, 배열의 요소가 될 수도 있고 자유롭게 사용할 수 있다는 의미

```js
var add = function foo(x,y){
    return x+y;
}
console.log(add(2,5)) // 7
//console.log(foo(2,5)) // 에러 발생 foo는 선언되지 않았다고 참조 에러 발생함
```

함수를 호출할 때는 함수 이름이 아니라 함수 객체를 가리키는 식별자를 사용해야한다.

### 함수 생성 시점과 함수 호이스팅

1. 함수 선언문

함수 선언문으로 정의하면 런타임 이전에 함수 객체가 먼저 생성된다. 그리고 함수이름과 동일한 이름의 식별자를 암묵적으로 생성하고 생성된 함수 객체를 할당한다.

`함수 호이스팅`

함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트의 고유한 특징

2. 함수 표현식

변수 선언은 런타임 이전에 실행되어 undefined로 초기화되지만 변수 할당문의 값은 할당문이 실행되는 시점, 즉 런타임에 평가됨.

함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하는 것이 아닌 `변수 호이스팅`이 발생한다.

```js
console.log(sum(2,5)) //7
//console.log(sub(2,5))//sub은 함수가 아니라고 타입에러

function sum(x,y){ //함수 선언문
    return x+y;
}

var sub=function(x,y){ //함수 표현식
    return x-y
}
```

함수 호이스팅은 함수를 호출하기 전에 반드시 함수를 선언해야한다는 당연한 규칙을 무시하므로 함수 선언문 대신 함수 표현식 쓰는 것을 권장

### Function 생성자 함수

```js
var add = new Function('x','y','return x+y');
```

해당 방식은 권장하지 않음

### 화살표 함수

```js
const add = (x,y)=>x+y;
```

## 함수 호출

### 매개변수와 인수

인수가 부족해서 인수가 할당되지 않은 매개변수의 값은 undefined다.

인수가 더 많은 경우 초과된 인수는 무시된다.

```js
function add(x,y){return x+y;}

console.log(add(2)); //NaN
console.log(add(2,5,7)) // 7
```

### 인수 확인

매개변수 기본값 : 매개변수에 인수를 전달하지 않았을 경우와 undefined를 전달한 경우에만 유효하다.

```js
function add(a=0, b=0, c=0){
    return a+b+c;
}
console.log(add()) // 0
```

### 매개변수의 최대 개수

매개변수는 최대 3개 이상을 넘지 않는 것을 권장한다. 그 이상의 매개변수가 필요하다면 하나의 매개변수를 선언하고 객체를 인수로 전달하는 것이 유리하다.

- 주의사항: 

    함수 외부에서 함수 내부로 전달한 객체를 함수 내부에서 변경하면 함수 외부의 객체가 변경되는 부수효과가 발생한다.

- 해결책: 

    객체의 깊은 복사를 통해 새로운 객체를 생성하고 재할당을 통해 교체한다.

## 참조에 의한 전달과 외부 상태의 변경

```js
function chageVal(primitive, obj){
    primitive +=100;
    obj.name = 'Kim';
}

var num = 100;
var person = {name:'Lee'};

console.log(num); // 100
console.log(person); // {name: 'Lee'}

// 원시값은 값 자체가 복사되어 전달되고 객체는 참조값이 복사되어 전달된다.
changeVal(num, person); 

console.log(num); // 100
console.log(person); // {name: 'Kim'}
```

## 다양한 함수의 형태

### 즉시 실행 함수

즉시 실행함수는 단 한번만 호출되며 다시 호출할 수 없다.

즉시 실행함수도 일반 함수처럼 값을 반환할 수 있고 인수를 전달할 수 있다.

```js
var res = (function(){
    var a = 3;
    var b= 5;
    return a*b;
}());

console.log(res); // 15

res = (function(a,b){
    return a*b;
}(3,5));

console.log(res); // 15
```

### 중첩함수
```js
// 외부함수
function outer(){
    var x  = 1;

    // 중첩함수 = 내부함수 = 헬퍼함수
    function inner(){
        var y = 2;
        console.log(x+y); // 3
    }
    inner();
}
outer();
```

### 콜백함수

함수의 변하지 않는 공통로직은 미리 정의해두고(고차함수), 
경우에 따라 변경되는 로직은 추상화애서 함수 외부에서 함수 내부로 전달하는 것이다.(콜백함수)

```js
//f: 콜백함수(함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수)
//repeat(): 고차함수(매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수) 
function repeat(n,f){
    for(var i=0;i<n;i++){
        f(i);
    }
}

var logAll=function(i){
    console.log(i);
};

var logOdds=function(i){
    if(i%2)console.log(i);
};

repeat(5,logAll); //logAll, logOdds는 콜백함수
repeat(5,logOdds);
```


콜백함수가 고차 함수 내부에만 호출된다면 콜백 함수를 익명함수 리터럴로 정의하면서 곧바로 고차 함수에 전달하는 것이 일반적이다.

```js
repeat(5,function(i){
    if(i%2)console.log(i);
}); //1 3
```

하지만 콜백함수로서 전달된 함수 리터럴은 고차 함수가 호출될 때마다 함수 객체를 생성하기 때문에

1. 콜백함수를 다른 곳에서도 호출할 필요가 있거나,
2. 콜백함수를 전달받는 함수가 자주 호출된다면 

함수 외부에서 콜백함수를 정의한 후 함수 참조를 고차 함수에 전달하는 편이 효율적이다.

### 순수 함수와 비순수 함수

- 순수 함수 :

    어떤 외부 상태(전역변수, 서버 데이터, 파일, DOM 등)에 의존하지도 않고 변경하지도 않는 즉, 부수효과가 없는 함수

    ```js
    var count = 0;

    function increase(n){
        return ++n;
    }

    // 순수함수가 반환한 결과값을 변수에 재할당해서 상태를 변경
    count = increase(count);
    console.log(count)l // 1
    ```

- 비순수 함수 :

    부수효과가 있는 함수

    ```js
    var count = 0;

    function increase(){
        return ++count;
    }
    console.log(count); // 1
    ```

    함수가 외부상태를 변경하면 상태 변화를 추적하기 어렵기 때문에 순수함수를 사용하는 것이 좋다.

    따라서 함수형 프로그래밍은 순수함수를 통해 부수 효과를 최대한 억제해 오류를 피하고 프로그램의 안정성을 높이려는 노력의 일환이다.

