# 12장 함수

## 12.1 함수란?
#### 함수
> 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것

```javascript
function add(x, y) {
  return x + y;
}
add(2, 5); // 7
```
|이름|뜻|예시|
|:---:|:---:|:---:|
|매개변수|함수 내부로 입력을 전달받는 변수|x, y|
|인수|입력|2,5|
|반환 값|출력|7|
|함수 이름||add|
|함수 정의||function add(x,y) { return x+y;}|
|함수 호출|인수를 매개변수를 통해 함수에 전달, 함수 실행 명시적 지시|add(2,5);|

## 12.2 함수를 사용하는 이유
- 코드의 재사용
	- 유지 보수 편의성
	- 코드의 신뢰성
- 이름 붙일 수 있음
	- 코드의 가독성 향상

## 12.3 함수 리터럴
- 함수는 객체 _[참고] 18장 함수와 일급 객체_
- 함수 리터럴로 생성 가능
- 일반 객체는 호출할 수 없지만 함수는 호출 가능

```javascript
var f = function add(x, y) {
  return x + y;
};
```
#### 함수 리터럴의 구성 요소
|구성 요소|설명|
|:---:|:---|
|함수 이름| - 식별자 네이밍 규칙 준수<br> - 함수 몸체 내에서만 참조 가능한 식별자 <br> - 이름 생략? '익명 함수' : '기명 함수'|
|매개변수 목록| - 식별자 네이밍 규칙 준수 <br> - 0개 이상의 매개변수를 소괄호로 감싸고 쉼표로 구분 <br> - 순서대로 할당|
|함수 몸체| - 함수 호출 시 일괄적으로 실행될 문을 하나의 실행 단위로 정의한 코드 블록 - <br> - 함수 몸체는 함수 호출에 의해 실행|

## 12.4 함수 정의
#### 함수 정의 방식

```javascript 
function add1(x, y) { return x + y; } 			//함수 선언문
var add2 = function add(x, y) { return x + y; }; 	// 함수 표현식
var add3 = new Function('x', 'y', 'return x + y'); 	// Function 생성자 함수
const add4 = (x, y) => x + y; ); 			//화살표 함수(ES6)
```
함수 표현식 사용 권장

#### 변수 선언과 함수 정의
- 변수는 선언, 함수는 정의
- 함수 선언문이 평가되면 식별자가 암묵적으로 생성되고 함수 객체 할당

### 12.4.1 함수 선언문
```javascript
function add(x, y) { // 이름 생략 X
  return x + y;
}

// console.dir은 함수 객체의 프로퍼티까지 출력
// 단, Node.js는 console.log와 같은 결과가 출력
console.dir(add); // ƒ add(x, y)

console.log(add(2, 5)); // 7
```
#### 함수 선언문
> 표현식이 아닌 문

- 실행 시 완료 값 undefined 출력
- 자바스크립트 엔진은 함수 선언문 해석해 함수 객체 생성
- 호출 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성, 거기에 함수 객체 할당
- 함수는 함수 이름으로 호출하는 게 아니라, 함수 객체를 가리키는 식별자로 호출

### 12.4.2 함수 표현식
```javascript
var add = function (x, y) {
  return x + y;
};
```

- 일급 객체 = 값의 성질을 갖는 객체
- 자바스크립트의 함수는 일급 객체

#### 함수 표현식
> 함수 리터럴로 생성한 함수 객체를 변수에 할당한 방식
- 표현식인 문
- 함수 이름 생략이 일반적
	 - 함수 이름은 함수 몸체 내부에서만 유효한 식별자
	 - 함수 이름으로 호출 불가

### 12.4.3 함수 생성 시점과 함수 호이스팅
- 함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점 다름
- 변수 할당문의 값, 함수 표현식의 함수 리터럴은 런타임에 평가되어 함수 객체가 됨
- 함수 표현식으로 함수를 정의하면 변수 호이스팅 발생
- 반드시 함수 표현식 이후에 참조 또는 호출해야 함

#### 함수 호이스팅
> 함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징
- 함수를 호출하기 전에 반드시 함수를 선언해야 한다는 당연한 규칙 무시
	-> 함수 선언문 대신 함수 표현식 사용 권장

### 12.4.4 Function 생성자 함수
```javascript
var add = new Function('x', 'y', 'return x + y');
```
- 비권장 : 클로저 생성 x, 함수 선언문, 함수 표현식 생성 함수와 다르게 동작

#### 생성자 함수
> 객체를 생성하는 함수 _[참고] 17장 생성자 함수에 의한 객체 생성_

### 12.4.5 화살표 함수
```javascript
const add = (x, y) => x + y;
```
- ES6 도입
- 항상 익명 함수
- 표현과 내부 동작 간략화 _[참고] 26.3 절 화살표 함수_
	 - 생성자 함수로 사용 x
	 - 기존 함수와 this 바인딩 방식이 다름
	 - prototype 프로퍼티 x
	 - arguments 객체 생성 x 

## 12.5 함수 호출
- 식별자와  함수 호출 연산자 `()`로 호출
- `()` 내에 0개 이상의 인수를 쉼표로 구분해 나열
- 함수를 호출하면 현재 흐름을 중단하고 호출된 함수로 실행 흐름을 옮김
- 매개 변수에 인수가 순서대로 할당, 함수 몸체의 문들 실행
 
### 12.5.1 매개변수와 인수
```javascript
function add(x, y) { return x + y; }

// 함수 호출 -> 인수: 1,2 매개변수: x, y
var result = add(1, 2);
```
매개변수를 통해  함수 외부 값을 내부 인수로 전달

#### 매개변수
- 함수 정의할 때 선언
- 스코프 : 함수 내부 _[참고] 13장 스코프_

#### 인수
- 매개변수가 인수를 전달함
- 값으로 표현될 수 있는 표현식
- 함수를 호출할 때 지정
- 개수와 타입에 제한 x
- 매개변수보다 인수가 모자라면 undefined
- 매개변수보다 인수가 더 많으면 무시
- 모든 인수는 arguments로 보관

```javascript
function add(x, y) {
  console.log(arguments);
  // Arguments(3) [2, 5, 10, callee: ƒ, Symbol(Symbol.iterator): ƒ]
  return x + y;
}
add(2, 5, 10);
```

### 12.5.2 인수 확인
- 자바스크립트 함수는 매개변수와 인수의 개수가 일치하는지 확인 X
- 자바스크립트는 동적 타입 언어 -> 매개 변수 타입 사전 지정 X
- 인수 확인 안할 시 런타임 에러 발생 가능성

#### 인수 확인법
- `typeof` 으로 체크
- 타입스크립트로 정적 타입 도입
- arguments로 인수 개수 확인
- 인수 전달 X -> 단축 평가로 매개변수에 기본값 할당 _[참고] 9.4절 단축 평가_
- 매개변수 기본값 사용 _[참고] 26.5절 매개변수 기본값_
	 -> 매개변수에 인수를 전달 안 했거나 undefined 전달한 경우에만

```javascript
function add(a=0, b, c) { //a : 매개변수 기본값 사용 
  if (typeof b !== 'number') { // b : `typeof` 으로 체크
    throw new TypeError('인수는 숫자 값이어야 합니다.');
  }
  c = c || 0; // c : 단축 평가
  console.log(arguments); // arguments로 인수 개수 확인
  return a + b + c;
}
```
### 12.5.3 매개변수의 최대 개수
#### 권장 매개변수 개수 : 최소화
- 함수는 한 가지 일만 해야 하며 가급적 작게
- 매개변수가 많으면 이해 어렵고 실수 발생
- 매개변수의 개수가 순서가 변경되면 유지보수성이 나빠짐

#### 객체를 인수로 전달
- 인수가 3개 이상일 때는 객체로 처리
- 프로퍼티 키만 정확하면 순서 신경 안 써도 됨
- 가독성 좋아지고 실수 줄어듦
- 부수 효과 _[참고] 12.6절 참조에 의한 전달과 외부 상태의 변경_
	- 함수 내부로 전달된 객체를 함수 내부에서 변경하면 함수 외부 객체가 변경

### 12.5.4 반환문
```javascript
function multiply(x, y) {
  return x * y; // 반환문
  console.log('실행되지 않는다.');   // 반환문 이후 문은 실행되지 않고 무시
}
var result = multiply(3, 5);
console.log(result); // 15

function foo () {
  return;
}
console.log(foo()); // undefined
```
- `return` 과 표현식으로 구성
- 함수 호출은 표현식이며 반환값으로 평가
1. 함수 실행 중단하고 함수 몸체를 빠져 나감
	- 반환문 이후 다른 문이 존재하면 실행되지 않고 무시
2. `return` 뒤에 오는 표현식을 평가해 반환
	- 반환값으로 사용할 표현식 명시가 없다면 undefined 반환
	- return과 표현식 사이에 줄바꿈이 있으면 의도치 않은 결과 발생
		-[참고] 5.5절 세미콜론과 세미콜론 자동 삽입 기능_
	- 전역문에서 `return`을 쓰면 문법 에러 발생

## 12.6 참조에 의한 전달과 외부 상태의 변경
- 원시값은 값에 의한 전달, 객체는 참조에 의한 전달 _[참고] 11장 원시 값과 객체의 비교_

#### 객체 변경 부수효과
- 함수 내부로 전달된 객체를 함수 내부에서 변경하면 함수 외부 객체가 변경
- 코드 복잡성을 증가시키고 가독성 해치는 원인

### 객체 변경 부수효과에 대한 대응
 - 옵저버 패턴을 통해 객체 참조 공유하는 모든 이들에게 사실을 통지하고 대처
 - 객체를 불변 객체로 만들어 사용
	- 객체의 상태 변경 원천 봉쇄
	- 객체 상태 변경이 필요할 경우, 방어적 복사
		- 깊은 복사를 통해 새로운 객체를 생성하고 재할당을 통해 교체

#### 순수 함수 
> 외부 상태를 변경하지 않고 외부 상태에 의존하지도 않는 함수
_[참고] 12.7.5절 순수 함수와 비순수 함수_

#### 함수형 프로그래밍
> 순수 함수를 통해 부수 효과를 최대한 억제하여 오류를 피하고 프로그램의 안정성을 높이려는 프로그래밍 패러다임

## 12.7 다양한 함수의 형태
### 12.7.1 즉시 실행 함수
> 함수 정의와 동시에 즉시 호출되는 함수
```javascript
// 익명 즉시 실행 함수
var res = (function () {
  var a = 3;
  var b = 5;
  return a * b;
}(3, 5));
console.log(res);
```
- 일회용
- 기명 즉시 실행 함수도 이름으로 재호출 불가
- `()` 그룹 연산자로 감싸서 실행하는 것이 일반적
- 일반 함수처럼 값 반환 가능, 인수 전달 가능
- 즉시 실행 함수 내에 코드를 모아 두면 혹시 있을 수도 있는 변수나 함수 이름 충돌 방지 가능
_[참고] 14.3절 전역 변수의 사용을 억제하는 방법

### 12.7.2 재귀 함수
> 재귀 호출을 수행하는 함수

#### 재귀 호출
함수가 자기 자신을 호출하는 것

```javascript
var factorial = function foo(n) {
  if (n <= 1) return 1;
  return n * factorial(n - 1);
};
console.log(factorial(5)); // 5! = 5 * 4 * 3 * 2 * 1 = 120
```

- 함수 이름은 함수 몸체 내부에서만 유효
- 함수 내부에서는 함수 이름을 사용해 자기 자신 호출 가능
- 함수를 가리키는 식별자로도 재귀 호출 가능
- 함수 외부에서 호출하려면 반드시 함수를 가리키는 식별자여야 함
- 탈출 조건을 만들지 않을 경우 스택 오버플로 에러 발생
- 대부분의 재귀함수는 반복문으로 변환 가능

### 12.7.3 중첩 함수
> 함수 내부에 정의된 함수. 내부함수라고도 함
- 외부 함수 내에서만 호출 가능
- 일반적으로 외부 함수를 돕는 헬프 함수의 역할을 함
- if문, for 문 안에서도 정의 가능 -> 호이스팅으로 인한 혼란 방지 위해 비권장

#### 외부 함수
> 중첩 함수를 포함하는 함수

```javascript
function outer() {
  var x = 1;

  // 중첩 함수
  function inner() {
    var y = 2; // 외부함수 변수 참조 가능
    console.log(x + y); // 3
  }
  inner();
}
outer();
```

### 12.7.4 콜백 함수
> 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수

#### 고차 함수
> 매개변수를 통해 함수의 외부에서 콜백 함수를 전달 받은 함수
- 콜백 함수를 자신의 일부분으로 합성
- 매개변수를 통해 전달받은 콜백 함수의 호출 시점을 결정해서 호출
- 필요에 따라 콜백 함수에 인수를 전달
_[참고] 27.9절 배열 고차 함수_

- 콜백 함수로서 전달된 함수 리터럴은 고차 함수가 호출될 때마다 평가되어 함수 객체 생성
- 콜백 함수가 고차 함수 내부에만 호출
	-> 콜백 함수를 익명 함수 리터럴로 정의하면서 곧바로 고차함수에 전달
- 콜백 함수가 자주 호출
	 -> 외부에 콜백함수를 정의해 고차함수에 전달하는 편이 효율적

```javascript
repeat(5, function (i) { // 콜백 함수 :익명 함수 리터럴
  if (i % 2) console.log(i); 
}); // 1 3
// 익명 함수 리터럴은 repeat 함수를 호출할 때마다 평가되어 함수 객체 생성

var logOdds = function (i) {  // logOdds 함수는 단 한 번만 생성
  if (i % 2) console.log(i);
};
repeat(5, logOdds); // 1 3 // 고차 함수에 함수 참조를 전달
```

- 비동기 처리, 배열 고차 함수에도 사용

```javascript
setTimeout(function () {  // 콜백 함수를 사용한 비동기 처리
  console.log('1초 경과');
}, 1000);

var res = [1, 2, 3].map(function (item) {  // 콜백 함수를 사용하는 고차 함수 map
  return item * 2;
});
```

### 12.7.5 순수 함수와 비순수 함수
#### 순수 함수 
> 외부 상태를 변경하지 않고 외부 상태에 의존하지도 않는, 부수 효과 없는 함수
- 동일한 인수가 전달되면 언제나 동일한 값 반환

#### 비순수 함수 
> 외부 상태를 변경하고 외부 상태에 의존하는, 부수 효과 있는 함수
- 동일한 인수가 전달되어도 외부 상태에 따라 반환 값 달라짐

```javascript
var count = 0;
function increase(n) { // 순수 함수 increase : 동일한 인수,  동일한 값을 반환
  return ++n;
}
// 순수 함수가 반환한 결과값을 변수에 재할당해 상태를 변경
count = increase(count);

count = 0; //  increase 함수에 의해 변화
function increase() { //비순수 함수 : 외부 상태에 의존하며 외부 상태를 변경
  return ++count;
}
// 비순수 함수는 외부 상태(count)를 변경하므로 상태 변화를 추적하기 어려워짐
increase();
```
