### var 키워드로 선언한 변수의 문제점

1. **변수 중복 선언 허용**
2. **함수 레벨 스코프**
3. **변수 호이스팅**

**변수 중복 선언 허용**

- 동일한 변수가 선언되었음을 모르고 값을 할당한다면 기존 변수의 값이 변경되는 부작용

**함수 레벨 스코프**

- 함수의 코드 블록만을 지역 스코프로 인정한다.
- 함수 외부에서 선언되면 전역으로 간주된다.
    - for문 안의 var i 도 전역이다.

**변수 호이스팅**

- 변수 선언이전에 호출가능하며 undefined 를 반환

### let 키워드

1. 변수 중복 선언 금지
2. 블록 레벨 스코프
3. 변수 호이스팅

**변수 중복 선언 금지**

- 변수 중복 선언시 SyntaxError

**블록 레벨 스코프**

- 모든 코드 블록을 지역 스코프로 인정한다.

```jsx
let foo = 1;

{
	let foo = 2;
	let bar = 3;
}

console.log(foo); //1
console.log(bar); // ReferenceError
```

**변수 호이스팅**

var 의 호이스팅

1. 선언단계, 초기화 단계
2. 할당 단계

- 선언단계와 초기화 단계를 동시에 진행해 undefined를 할당할 수 있음

let 의 호이스팅

1. 선언단계
2. TDZ (일시적 사각지대)
3. 초기화단계
4. 할당 단계

- 초기화 단계가 진행되지 않으면 선언 단계에서의 호출은 ReferenceError
- 그렇다고 호이스팅이 안되는건 아니다.

**전역 객체와 let**

전역 var 는 window의 프로퍼티

let 은 보이지 않는 개념적인 블록에 존재하기에 window 의 프로퍼티가 아니다.

### const 키워드

**선언과 초기화**

- 반드시 선언과 동시에 초기화 해야한다.

**재할당 금지**

- 재할당이 안된다.

**상수**

- 원시 값을 할당한 const 변수는 변경할 수 없다.

**const 키워드와 객체**

- 객체를 할당하면 객체의 값을 변경할 수 있다.
    - 객체의 참조값이 변경되지 않지 객체 내부의 값은 변경가능하다.
- 재할당을 금지한다는것은 불변을 의미하지 않는다.